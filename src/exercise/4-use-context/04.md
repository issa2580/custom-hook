# useContext

C'est quoi `useContext` ? Il permet de partager de la logique (valeur, function)
entre plusieurs composants sans avoir Ã  passer des props.

Ce hooks rÃ©pond Ã  cette question :

> Comment passer une props Ã  un enfant qui est trÃ¨s loin dans le DOM ?

[ğŸ“– useContext - RÃ©cupÃ©rer des donnÃ©es du context](https://react.dev/reference/react/useContext)

[ğŸ“– createContext - CrÃ©er un context](https://react.dev/reference/react/createContext)

On va jeter un coup d'Å“il Ã  la doc ensemble, mais le meilleur moyen de comprendre reste la pratique.

## Exercice - Dark mode

On va faire un dark mode.

Dans le fichier exercice, j'ai dÃ©jÃ  fait toute la logique du dark mode.

Ta mission est de modifier notre application pour utiliser un Context afin
de ne pas passer des props de notre app Ã  tous les composants.

Pour Ã§a, comme d'habitude, tu as les Ã©mojis du Lienx pour t'aider.

- ğŸ’Œ Tu comprends comment utiliser les useContext

## Extra 2 - SÃ©curiser

Tu vois que l'on utilise tout le temps `useContext(ThemeContext);` et c'est pas
trÃ¨s propre.

Le mieux est de crÃ©er un custom hooks `useThemeContext` qui va retourner notre context
mais qui en plus **va vÃ©rifier que notre context n'est pas vide**. S'il est vide, c'est que nous sommes en dehors de notre provider !

Dans ce cas, on va throw une erreur !

On ne peut qu'utiliser un context quand dans l'arbre, au-dessus de notre composant,
il y a un context provider.

Si par mÃ©garde qqn utilise ce context hors du context provider, on veut qu'il
reÃ§oive une erreur.

Pour tester, tu peux tout simplement utiliser la fonction `useThemeContext` dans
le composant `App` et vÃ©rifier que tu as une erreur.

- ğŸ’Œ Tu comprends comment utiliser les custom hooks pour vÃ©rifier que le context
  est bien utilisÃ© et simplifer le code.

## Extra 3 - Getter et setter

Si tu ajoutes un `console.log` dans les boutons "Force light"
et "Force Dark", tu verras qu'ils sont rerender...

Mais ils n'utilisent pas le theme, ils le modifie. Ils n'ont mÃªme pas besoin
de savoir si c'est "light" ou "dark".

Pour Ã©viter de rerender les composants qui n'ont pas besoin de **lire** le thÃ¨me,
crÃ©e un deuxiÃ¨me context : "ThemeContextDispatch" qui va contenir les fonctions
`setLight`, `setDark` et `Toggle`.

ğŸ’¡ Tips de code :

```jsx
const values = { theme, isDark, isLight };
const dispatchValues = { setLight, setDark, toggle };

return (
  <ThemeContext.Provider value={values}>
    <ThemeContextDispatch.Provider value={dispatchValues}>
      {children}
    </ThemeContextDispatch.Provider>
  </ThemeContext.Provider>
);
```

Il faudra aussi crÃ©er `useThemeDispatchContext` pour utiliser ce context.

ğŸ’¡ AÃ¯e, Ã§a ne va pas fonctionner.

Effectivement, ici la value qu'on passe **est re-gÃ©nÃ©rÃ©e Ã  chaque render** !

Quand on fait `{ setLight, setDark, toggle }` on crÃ©e un nouvel objet Ã  chaque render.

Ce qui provoque le render de tous les composants qui utilisent notre context.

Pour rÃ©soudre ce problÃ¨me il faut utiliser `useMemo` !

ğŸ’¡ Tips de code

```jsx
const dispatchValues = useMemo(() => ({ setLight, setDark, toggle }), []);
```

useMemo **va garder le mÃªme objet entre les renders** sauf si le tableau
de dÃ©pendance change.

[ğŸ“– Un super article sur le useMemo](https://kentcdodds.com/blog/usememo-and-usecallback)
[ğŸ“– Le meilleur article sur useMemo](https://www.joshwcomeau.com/react/usememo-and-usecallback/)

- ğŸ’Œ Tu apprends Ã  optimiser un context
- ğŸ’Œ Tu apprends Ã  utiliser le useMemo
